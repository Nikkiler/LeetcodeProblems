/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;
import java.util.Arrays;
public class App {
    public static void main(String[] args) {
        int[] command = {4, -1, 3};
        int[][] obstacle = {};
        System.out.println(robotSim(command, obstacle));
    }
    public static int robotSim(int[] commands, int[][] obstacles) {
        int[] coords = {0, 0};
        char direction = 'n';
        int[] furhest = {0, 0};
        for (int i = 0; i < commands.length; i++) {
            if (commands[i] == -1 || commands[i] == -2) {
                direction = directionChange(commands[i], direction);
            } else {
                coords = movement(direction, coords, commands[i], obstacles);
                if (((coords[0] * coords[0]) + (coords[1] * coords[1])) > ((furhest[0] * furhest[0]) + (furhest[1] * furhest[1]))) {
                    furhest[1] = coords[1];
                    furhest[0] = coords[0];
                }
            }
        }
        return (furhest[0] * furhest[0]) + (furhest[1] * furhest[1]);
    }
    public static int[] movement(char direction, int[] coords, int command, int[][] obstacle) {
        switch (direction) {
            case 'n':
                int[] result1 = {0, 0};
                if (obstacle.length > 0) {
                    for (int j = 0; j < obstacle.length; j++) {
                        if (coords[0] == obstacle[j][0] && coords[1] < obstacle[j][1]) {
                            if (coords[1] + command >= obstacle[j][1]) {
                                result1 = new int[]{coords[0], obstacle[j][1] - 1};
                                return result1;
                            }
                        }

                    }
                }
                coords[1] = coords[1] + command;
                return coords;
            case 'e':
                int[] result2 = {0, 0};
                if (obstacle.length > 0) {
                    for (int j = 0; j < obstacle.length; j++) {
                        if (coords[1] == obstacle[j][1] && coords[0] < obstacle[j][0]) {
                            if (coords[0] + command >= obstacle[j][0]) {
                                result2 = new int[]{obstacle[j][0] - 1, coords[1]};
                                return result2;
                            }
                        }

                    }
                }
                coords[0] = coords[0] + command;
                return coords;


            case 's':
                int[] result3 = {0, 0};
                if (obstacle.length > 0) {
                    for (int j = 0; j < obstacle.length; j++) {
                        if (coords[0] == obstacle[j][0] && coords[1] > obstacle[j][1]) {
                            if (coords[1] - command <= obstacle[j][1]) {
                                result3 = new int[]{coords[0], obstacle[j][1] + 1};
                                return result3;
                            }
                        }
                    }
                }
                coords[1] = coords[1] - command;
                return coords;

            case 'w':
                int[] result4 = {0, 0};
                if (obstacle.length > 0) {
                    for (int j = 0; j < obstacle.length; j++) {
                        if (coords[1] == obstacle[j][1] && coords[0] > obstacle[j][0]) {
                            if (coords[0] - command <= obstacle[j][0]) {
                                result4 = new int[]{obstacle[j][0] + 1, coords[1]};
                                return result4;
                            }
                        }

                    }
                }
                coords[0] = coords[0] - command;
                return coords;
        }
        return coords;
    }
    public static char directionChange(int change, char direction) {
        switch (change) {
            case -2:
                switch (direction) {
                    case 'n':
                        return 'w';
                    case 'e':
                        return 'n';
                    case 's':
                        return 'e';
                    case 'w':
                        return 's';
                }
            case -1:
                switch (direction) {
                    case 'n':
                        return 'e';
                    case 'e':
                        return 's';
                    case 's':
                        return 'w';
                    case 'w':
                        return 'n';
                }

        }
        return direction;
    }
    public static int[] furthest(int[] coords, int[] furhest) {
        if ((coords[0] + coords[1]) > (furhest[0] + furhest[1])) {
            furhest[0] = coords[0];
            furhest[1] = coords[1];
        }
        return furhest;
    }
}
